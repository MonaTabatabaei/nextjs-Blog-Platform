/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Blog Platform API
 * OpenAPI spec version: 1.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import { customFetcher } from './fetcher';
export type GetCommentsParams = {
/**
 * When provided, filters comments to a single post.
 */
postId?: number;
};

/**
 * Optional extra information about the error.
 */
export type ErrorDetails = { [key: string]: unknown };

export interface Error {
  /** Optional machine-readable error code. */
  code?: string;
  /** Optional extra information about the error. */
  details?: ErrorDetails;
  message: string;
}

/**
 * Unexpected server error.
 */
export type ServerErrorResponse = Error;

/**
 * Resource not found.
 */
export type NotFoundResponse = Error;

/**
 * Invalid request parameters or payload.
 */
export type BadRequestResponse = Error;

export type UserCompany = {
  bs?: string;
  catchPhrase?: string;
  name?: string;
};

export type UserAddress = {
  city?: string;
  street?: string;
  suite?: string;
  zipcode?: string;
};

export interface User {
  address?: UserAddress;
  company?: UserCompany;
  email?: string;
  id?: number;
  name?: string;
  phone?: string;
  username?: string;
  website?: string;
}

export interface NewComment {
  body: string;
  email: string;
  name: string;
  postId: number;
}

export interface Comment {
  body: string;
  email: string;
  id: number;
  name: string;
  postId: number;
}

export interface Post {
  body: string;
  id: number;
  title: string;
  userId: number;
}




type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1];


/**
 * @summary Get all posts
 */
export const getPosts = (
    
 options?: SecondParameter<typeof customFetcher>,signal?: AbortSignal
) => {
      
      
      return customFetcher<Post[]>(
      {url: `/posts`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPostsQueryKey = () => {
    return [`/posts`] as const;
    }

    
export const getGetPostsQueryOptions = <TData = Awaited<ReturnType<typeof getPosts>>, TError = ServerErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosts>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPostsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPosts>>> = ({ signal }) => getPosts(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPosts>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPostsQueryResult = NonNullable<Awaited<ReturnType<typeof getPosts>>>
export type GetPostsQueryError = ServerErrorResponse

/**
 * @summary Get all posts
 */
export const useGetPosts = <TData = Awaited<ReturnType<typeof getPosts>>, TError = ServerErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPosts>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPostsQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get a single post by ID
 */
export const getPostById = (
    id: number,
 options?: SecondParameter<typeof customFetcher>,signal?: AbortSignal
) => {
      
      
      return customFetcher<Post>(
      {url: `/posts/${id}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPostByIdQueryKey = (id: number,) => {
    return [`/posts/${id}`] as const;
    }

    
export const getGetPostByIdQueryOptions = <TData = Awaited<ReturnType<typeof getPostById>>, TError = NotFoundResponse | ServerErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostById>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPostByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostById>>> = ({ signal }) => getPostById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPostById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPostByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPostById>>>
export type GetPostByIdQueryError = NotFoundResponse | ServerErrorResponse

/**
 * @summary Get a single post by ID
 */
export const useGetPostById = <TData = Awaited<ReturnType<typeof getPostById>>, TError = NotFoundResponse | ServerErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostById>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPostByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * JSONPlaceholder supports getting comments for a specific post
via `/posts/{id}/comments`. This is equivalent to filtering
`GET /comments` by `postId`.

 * @summary Get comments for a post (by path param)
 */
export const getPostCommentsById = (
    id: number,
 options?: SecondParameter<typeof customFetcher>,signal?: AbortSignal
) => {
      
      
      return customFetcher<Comment[]>(
      {url: `/posts/${id}/comments`, method: 'GET', signal
    },
      options);
    }
  

export const getGetPostCommentsByIdQueryKey = (id: number,) => {
    return [`/posts/${id}/comments`] as const;
    }

    
export const getGetPostCommentsByIdQueryOptions = <TData = Awaited<ReturnType<typeof getPostCommentsById>>, TError = NotFoundResponse | ServerErrorResponse>(id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostCommentsById>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetPostCommentsByIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getPostCommentsById>>> = ({ signal }) => getPostCommentsById(id, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getPostCommentsById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetPostCommentsByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPostCommentsById>>>
export type GetPostCommentsByIdQueryError = NotFoundResponse | ServerErrorResponse

/**
 * @summary Get comments for a post (by path param)
 */
export const useGetPostCommentsById = <TData = Awaited<ReturnType<typeof getPostCommentsById>>, TError = NotFoundResponse | ServerErrorResponse>(
 id: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getPostCommentsById>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetPostCommentsByIdQueryOptions(id,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Used to resolve author information for blog posts.
 * @summary Get all users
 */
export const getUsers = (
    
 options?: SecondParameter<typeof customFetcher>,signal?: AbortSignal
) => {
      
      
      return customFetcher<User[]>(
      {url: `/users`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUsersQueryKey = () => {
    return [`/users`] as const;
    }

    
export const getGetUsersQueryOptions = <TData = Awaited<ReturnType<typeof getUsers>>, TError = ServerErrorResponse>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUsers>>> = ({ signal }) => getUsers(requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = ServerErrorResponse

/**
 * @summary Get all users
 */
export const useGetUsers = <TData = Awaited<ReturnType<typeof getUsers>>, TError = ServerErrorResponse>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUsers>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUsersQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Get user info by ID
 */
export const getUserById = (
    userId: number,
 options?: SecondParameter<typeof customFetcher>,signal?: AbortSignal
) => {
      
      
      return customFetcher<User>(
      {url: `/users/${userId}`, method: 'GET', signal
    },
      options);
    }
  

export const getGetUserByIdQueryKey = (userId: number,) => {
    return [`/users/${userId}`] as const;
    }

    
export const getGetUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof getUserById>>, TError = NotFoundResponse | ServerErrorResponse>(userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetUserByIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({ signal }) => getUserById(userId, requestOptions, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData> & { queryKey: QueryKey }
}

export type GetUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUserById>>>
export type GetUserByIdQueryError = NotFoundResponse | ServerErrorResponse

/**
 * @summary Get user info by ID
 */
export const useGetUserById = <TData = Awaited<ReturnType<typeof getUserById>>, TError = NotFoundResponse | ServerErrorResponse>(
 userId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetUserByIdQueryOptions(userId,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Returns all comments, or comments for a specific post when
`postId` query parameter is provided. This matches the usage
in the app where comments are fetched via `GET /comments?postId={id}`.

 * @summary Get comments (optionally filtered by postId)
 */
export const getComments = (
    params?: GetCommentsParams,
 options?: SecondParameter<typeof customFetcher>,signal?: AbortSignal
) => {
      
      
      return customFetcher<Comment[]>(
      {url: `/comments`, method: 'GET',
        params, signal
    },
      options);
    }
  

export const getGetCommentsQueryKey = (params?: GetCommentsParams,) => {
    return [`/comments`, ...(params ? [params]: [])] as const;
    }

    
export const getGetCommentsQueryOptions = <TData = Awaited<ReturnType<typeof getComments>>, TError = BadRequestResponse | ServerErrorResponse>(params?: GetCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetCommentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getComments>>> = ({ signal }) => getComments(params, requestOptions, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData> & { queryKey: QueryKey }
}

export type GetCommentsQueryResult = NonNullable<Awaited<ReturnType<typeof getComments>>>
export type GetCommentsQueryError = BadRequestResponse | ServerErrorResponse

/**
 * @summary Get comments (optionally filtered by postId)
 */
export const useGetComments = <TData = Awaited<ReturnType<typeof getComments>>, TError = BadRequestResponse | ServerErrorResponse>(
 params?: GetCommentsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getComments>>, TError, TData>>, request?: SecondParameter<typeof customFetcher>}

  ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } => {

  const queryOptions = getGetCommentsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * JSONPlaceholder simulates a POST /comments request and always
returns a created comment without persisting it.

 * @summary Create a comment (simulated)
 */
export const createComment = (
    newComment: NewComment,
 options?: SecondParameter<typeof customFetcher>,) => {
      
      
      return customFetcher<Comment>(
      {url: `/comments`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: newComment
    },
      options);
    }
  


export const getCreateCommentMutationOptions = <TError = BadRequestResponse | ServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{data: NewComment}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{data: NewComment}, TContext> => {
const {mutation: mutationOptions, request: requestOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createComment>>, {data: NewComment}> = (props) => {
          const {data} = props ?? {};

          return  createComment(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCommentMutationResult = NonNullable<Awaited<ReturnType<typeof createComment>>>
    export type CreateCommentMutationBody = NewComment
    export type CreateCommentMutationError = BadRequestResponse | ServerErrorResponse

    /**
 * @summary Create a comment (simulated)
 */
export const useCreateComment = <TError = BadRequestResponse | ServerErrorResponse,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createComment>>, TError,{data: NewComment}, TContext>, request?: SecondParameter<typeof customFetcher>}
): UseMutationResult<
        Awaited<ReturnType<typeof createComment>>,
        TError,
        {data: NewComment},
        TContext
      > => {

      const mutationOptions = getCreateCommentMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
